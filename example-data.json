{
  "nodes": [
    {
      "id": "client1",
      "x": 200,
      "y": 700,
      "label": "Client 1",
      "type": "circle",
      "description": "Внешний клиент (WebRTC + WebSocket). Подключается к WebSocket серверу для сигналинга WebRTC соединений."
    },
    {
      "id": "client2",
      "x": 200,
      "y": 900,
      "label": "Client 2",
      "type": "circle",
      "description": "Внешний клиент (WebRTC + WebSocket). Подключается к WebSocket серверу для сигналинга WebRTC соединений."
    },
    {
      "id": "websocket-server",
      "x": 600,
      "y": 800,
      "label": "WebSocket Server",
      "type": "rectangle",
      "description": "WebSocketServer на порту 5555. Обрабатывает connection, message и close события. Инициализирует heartbeat проверку. При отправке любого сообщения проверяет lastPingTime - если прошло более 5 минут без PING, соединение считается мертвым и закрывается."
    },
    {
      "id": "parse",
      "x": 900,
      "y": 800,
      "label": "parse.js",
      "type": "diamond",
      "description": "Парсинг входящих сообщений. Определяет тип сообщения: PING (простая строка) или JSON с route, userId, data. Обновляет lastPingTime при получении PING. Перед обработкой любого сообщения проверяет, не истек ли heartbeat (5 минут без PING) - если истек, соединение закрывается и восстанавливается через handleReconnect."
    },
    {
      "id": "startHeartbeat",
      "x": 900,
      "y": 1100,
      "label": "startHeartbeat",
      "type": "hexagon",
      "description": "Heartbeat проверка соединений. Запускается при старте сервера, проверяет все соединения каждые 30 секунд. Для каждого соединения проверяет lastPingTime - если прошло более 5 минут без PING, соединение закрывается как мертвое. Клиент должен переподключиться и отправить RECONNECT для восстановления. Также проверка выполняется перед обработкой каждого сообщения в parse.js."
    },
    {
      "id": "routes",
      "x": 1200,
      "y": 800,
      "label": "routes.js",
      "type": "rectangle",
      "description": "Маршрутизация сообщений. Маппинг route из JSON сообщения на соответствующую функцию-обработчик (handler)."
    },
    {
      "id": "handlePing",
      "x": 1500,
      "y": 400,
      "label": "handlePing",
      "type": "rectangle",
      "description": "Обработка PING сообщения. Отправляет PONG обратно клиенту. Вызывается при получении строки 'PING' (lastPingTime обновляется в parse.js). PING должен отправляться клиентом каждые 30 секунд для поддержания соединения. При отсутствии PING более 5 минут соединение закрывается heartbeat проверкой."
    },
    {
      "id": "handleAddUser",
      "x": 1500,
      "y": 600,
      "label": "handleAddUser",
      "type": "rectangle",
      "description": "Добавление нового пользователя. Создает или обновляет сессию пользователя в users Map. Проверяет waiting list для входящих звонков."
    },
    {
      "id": "handleReconnect",
      "x": 1500,
      "y": 800,
      "label": "handleReconnect",
      "type": "rectangle",
      "description": "Восстановление сессии пользователя при переподключении. Вызывается автоматически при обнаружении мертвого соединения (heartbeat timeout > 5 минут) или при явном переподключении. Очищает мертвые соединения, восстанавливает состояние (status, candidate, streamIds). Клиент должен переподключиться и отправить RECONNECT для восстановления сессии."
    },
    {
      "id": "handleOffer",
      "x": 1500,
      "y": 1000,
      "label": "handleOffer",
      "type": "rectangle",
      "description": "Обработка WebRTC Offer. Инициация звонка: устанавливает статус 'calling', создает связи между пользователями, добавляет в waiting list, отправляет /call получателю. Перед обработкой проверяется lastPingTime - если соединение мертвое (>5 минут без PING), оно закрывается."
    },
    {
      "id": "handleAnswer",
      "x": 1500,
      "y": 1200,
      "label": "handleAnswer",
      "type": "rectangle",
      "description": "Обработка WebRTC Answer. Принятие звонка: устанавливает статус 'ringing', создает пару через setPair, отправляет /acceptCall инициатору, рассылает /connect."
    },
    {
      "id": "handleDecline",
      "x": 1500,
      "y": 1400,
      "label": "handleDecline",
      "type": "rectangle",
      "description": "Отклонение звонка. Сбрасывает статусы на 'idle'/'ended', отправляет /decline инициатору, удаляет пару через removePair."
    },
    {
      "id": "handleAddIce",
      "x": 1500,
      "y": 1600,
      "label": "handleAddIce",
      "type": "rectangle",
      "description": "Сбор ICE кандидатов. Сохраняет iceParams в объекте пользователя для последующего обмена при установлении WebRTC соединения."
    },
    {
      "id": "handleSwap",
      "x": 1500,
      "y": 1800,
      "label": "handleSwap",
      "type": "rectangle",
      "description": "Обмен ICE кандидатами. Обменивает iceParams между двумя пользователями в паре, отправляет /swapIce каждому с кандидатами другого, устанавливает статус 'in_call'."
    },
    {
      "id": "handleSetRemoteStreamId",
      "x": 1500,
      "y": 2000,
      "label": "handleSetRemoteStreamId",
      "type": "rectangle",
      "description": "Установка ID удалённого трека. Сохраняет streamIds (audio/video track IDs) для конкретного пользователя в объекте пользователя."
    },
    {
      "id": "handleUpdateMedia",
      "x": 1500,
      "y": 2200,
      "label": "handleUpdateMedia",
      "type": "rectangle",
      "description": "Обновление медиа-настроек. Передает изменения медиа-параметров (mute, video toggle и т.д.) кандидату через /updateMedia."
    },
    {
      "id": "handleUpdateOffer",
      "x": 1500,
      "y": 2400,
      "label": "handleUpdateOffer",
      "type": "rectangle",
      "description": "Обновление SDP Offer. Используется для реконнекта WebRTC соединения. Отправляет /updateOffer с новым SDP без изменения статусов."
    },
    {
      "id": "handleUpdateAnswer",
      "x": 1500,
      "y": 2600,
      "label": "handleUpdateAnswer",
      "type": "rectangle",
      "description": "Обновление SDP Answer. Используется для реконнекта WebRTC соединения. Отправляет /updateAnswer и рассылает /updateIce для обновления ICE."
    },
    {
      "id": "userManagement",
      "x": 1800,
      "y": 1000,
      "label": "users/index.js",
      "type": "rectangle",
      "description": "Управление пользователями. Функции: getPair, setPair, removePair, removeUser, updateStatus, pushInWaitingList, removeFromWaitingList, getFromWaitingList, isSendingOnePeers."
    },
    {
      "id": "sendMessage",
      "x": 1800,
      "y": 1400,
      "label": "send.js",
      "type": "rectangle",
      "description": "Отправка сообщений клиентам. Функции sendMessage и sendCancelMessage. Форматирует данные через formData и отправляет через WebSocket конкретному пользователю или всем сессиям пользователя. Перед отправкой проверяется lastPingTime - если соединение мертвое (>5 минут без PING), сообщение не отправляется, соединение закрывается."
    },
    {
      "id": "broadcast",
      "x": 1800,
      "y": 1800,
      "label": "broadcast.js",
      "type": "rectangle",
      "description": "Рассылка сообщений паре. Отправляет сообщение обоим пользователям в паре одновременно (например, /connect, /updateIce)."
    },
    {
      "id": "usersStorage",
      "x": 2100,
      "y": 800,
      "label": "users Map",
      "type": "circle",
      "description": "Хранилище пользователей. Map<userId, Map<WebSocket, UserData>>. Хранит все активные сессии пользователей. Каждый userId может иметь несколько WebSocket соединений."
    },
    {
      "id": "pairOfPeers",
      "x": 2100,
      "y": 1000,
      "label": "pairOfPeers",
      "type": "circle",
      "description": "Пары пользователей. Object {userId: candidateId}. Двунаправленная связь между пользователями в активном звонке. Используется для быстрого поиска собеседника."
    },
    {
      "id": "waitingList",
      "x": 2100,
      "y": 1200,
      "label": "waitingList",
      "type": "circle",
      "description": "Список ожидающих звонков. Object {userId: callData}. Хранит данные входящих звонков для пользователей, которые еще не обработали ADD_USER. Автоматически очищается через 1 минуту."
    },
    {
      "id": "handleException",
      "x": 1800,
      "y": 2200,
      "label": "sendError.js",
      "type": "rectangle",
      "description": "Централизованная обработка ошибок. Логирует ошибку, отправляет уведомление в Telegram через sendBroadcast, отправляет ошибку клиенту через WebSocket."
    },
    {
      "id": "logger",
      "x": 2100,
      "y": 2200,
      "label": "logger.js",
      "type": "rectangle",
      "description": "Логирование ошибок. Записывает ошибки в файл logs/server.log с меткой времени и информацией об ошибке."
    },
    {
      "id": "telegramLogs",
      "x": 2100,
      "y": 2400,
      "label": "telegramLogs.js",
      "type": "rectangle",
      "description": "Telegram уведомления. Отправляет логи и ошибки в Telegram канал через node-telegram-bot-api для мониторинга в реальном времени."
    }
  ],
  "edges": [
    { "from": "client1", "to": "websocket-server", "label": "WebSocket Connection" },
    { "from": "client2", "to": "websocket-server", "label": "WebSocket Connection" },
    { "from": "websocket-server", "to": "parse", "label": "message" },
    { "from": "parse", "to": "routes", "label": "route + data" },
    { "from": "parse", "to": "startHeartbeat", "label": "check lastPingTime" },
    { "from": "startHeartbeat", "to": "handleReconnect", "label": "timeout > 5min" },
    { "from": "routes", "to": "handleAddUser", "label": "ADD_USER" },
    { "from": "routes", "to": "handleReconnect", "label": "RECONNECT" },
    { "from": "routes", "to": "handleOffer", "label": "OFFER" },
    { "from": "routes", "to": "handleAnswer", "label": "ANSWER" },
    { "from": "routes", "to": "handleDecline", "label": "DECLINE" },
    { "from": "routes", "to": "handleAddIce", "label": "ADD_ICE" },
    { "from": "routes", "to": "handleSwap", "label": "SWAP_ICE" },
    { "from": "routes", "to": "handleSetRemoteStreamId", "label": "SET_REMOTE_STREAM_ID" },
    { "from": "routes", "to": "handleUpdateMedia", "label": "MEDIA_UPDATE" },
    { "from": "routes", "to": "handleUpdateOffer", "label": "UPDATE_OFFER" },
    { "from": "routes", "to": "handleUpdateAnswer", "label": "UPDATE_ANSWER" },
    { "from": "routes", "to": "handlePing", "label": "PING" },
    { "from": "websocket-server", "to": "startHeartbeat", "label": "startHeartbeat()" },
    { "from": "handleAddUser", "to": "userManagement", "label": "uses" },
    { "from": "handleReconnect", "to": "userManagement", "label": "uses" },
    { "from": "handleOffer", "to": "userManagement", "label": "uses" },
    { "from": "handleAnswer", "to": "userManagement", "label": "uses" },
    { "from": "handleDecline", "to": "userManagement", "label": "uses" },
    { "from": "handleSwap", "to": "userManagement", "label": "uses" },
    { "from": "handleOffer", "to": "sendMessage", "label": "sendMessage()" },
    { "from": "handleAnswer", "to": "sendMessage", "label": "sendMessage()" },
    { "from": "handleAnswer", "to": "broadcast", "label": "broadcast()" },
    { "from": "handleSwap", "to": "sendMessage", "label": "sendMessage()" },
    { "from": "handleUpdateOffer", "to": "sendMessage", "label": "sendMessage()" },
    { "from": "handleUpdateAnswer", "to": "sendMessage", "label": "sendMessage()" },
    { "from": "handleUpdateAnswer", "to": "broadcast", "label": "broadcast()" },
    { "from": "handleUpdateMedia", "to": "sendMessage", "label": "sendMessage()" },
    { "from": "userManagement", "to": "usersStorage", "label": "read/write" },
    { "from": "userManagement", "to": "pairOfPeers", "label": "read/write" },
    { "from": "userManagement", "to": "waitingList", "label": "read/write" },
    { "from": "sendMessage", "to": "websocket-server", "label": "ws.send()" },
    { "from": "broadcast", "to": "websocket-server", "label": "ws.send()" },
    { "from": "websocket-server", "to": "client1", "label": "response" },
    { "from": "websocket-server", "to": "client2", "label": "response" },
    { "from": "handleAddUser", "to": "handleException", "label": "on error" },
    { "from": "handleOffer", "to": "handleException", "label": "on error" },
    { "from": "handleAnswer", "to": "handleException", "label": "on error" },
    { "from": "handleDecline", "to": "handleException", "label": "on error" },
    { "from": "handleSwap", "to": "handleException", "label": "on error" },
    { "from": "handleException", "to": "logger", "label": "logError()" },
    { "from": "handleException", "to": "telegramLogs", "label": "sendBroadcast()" }
  ]
}
